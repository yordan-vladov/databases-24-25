# Нерелационни Бази Данни

---
## Съдържание

- Какво са нерелационни бази данни?
- Видове нерелационни бази данни.
---
## Релационни бази данни

- Данните са пазят под формата на релации (таблици).
- Таблиците формират **релации** по между си чрез **ключове**.
- **Примери:** MySQL, MariaDB, PostgreSQL
---
### Релационни бази данни - предимства

- Данните са ясно структурирани и организирани.
- Спазват **ACID** принципите.
- Добре развити.
---
### Релационни бази данни - недостатъци

- Данните не са гъвкави.
- Могат да бъдат сложни за проектиране.
- Превеждане на данни от backend към БД може да бъде сложно.
---
### ООП към Релационна ДБ

![](/Attachments/DB-nosql-1.png)

---

![](/Attachments/DB-nosql-2.png)

---
- Ако искаме нашата да отговаря на много различни нужди и да надживее приложенията, с които работи, тогава релационните са добър избор.
---
## Нерелационни БД

- Бази Данни, които пазят  данните по различен начин от релационните.
- Също така наричани **NoSQL**.
- По-подходящи за определени задачи.
---
## Видове NoSQL Бази данни

- Key-Value
- Graph
- Document
- ...
---
## Key-Value

- Базите данни се пазят под формата на **key-value** двойки, подобно на речник или hashmap.
- Оптимизирани за прости, но изключително бързи заявки.
- **Пример:** Redis, DynamoDB.
---
### Key-Value Use Case

- Разработваме уеб приложение с милиони потребители.
- Всеки път, когато потребителят влезе, искаме да неговата сесия (userID, време на изтичане, предпочитания, т.н.)
---
### Опция 1 - Релационна БД

- Създаваме таблица `sessions`:

| session_id | user_id | data | expires_at     |
| ---------- | ------- | ---- | -------------- |
| 23         | 5       | ...  | 2025-04-20-... |
| ...        | ..      | ...  | ...            |

---
### Опция 1 - Проблеми

- Всяко зареждане на страница изисква заявка за проверка на сесията.
- При сериозно натоварване, това може да забави сървъра.
---
### Опция 2 - Key-Value БД

- За всяка сесия използваме **key-value** двойка:
    - **Key:** `session:abc123`
    - **Value:** `{ "user_id": 42, "preferences": { "theme": "dark" }, "expires_at": 1735689600 }`
---
- Записване и извличането на данни е много по-бързо, понеже се пази в паметта, а не в диска.
- Хоризонталното скалиране е много по-лесно.
---
### Key-Value БД - Предимства

- Скорост.
- Простота.
- Скалируемост.
---
### Key-Value БД - Недостатъци

- Не можем моделираме сложни данни с много релации.
- Не можем да изпълняваме сложни заявки (филтриране, групиране, подреждане, ...).
---
## Graph-Based

- Използва графи с възли и връзки за да моделират данните.
- Оптимизирани за случаи, където връзките са важни важни колкото данните.
- **Пример:** Neo4j
---
## Graph Use Case

- Разработваме социална мрежа, където трябва:
    1. Намираме приятели на приятели (Връзки от 2-ра степен)
    2. Препоръчваме нови приятели
    3. Анализираме приятелски кръгове и как информация се пренася през мрежата
---

![](/Attachments/DB-nosql-3.png)

---
### Опция 1 - Релационна БД

- Създаваме таблица `friendships`:

| frienship_id | user_id | friend_id | friends_since  |
| ------------ | ------- | --------- | -------------- |
| 13           | 5       | 7         | 2023-03-03-... |
| ...          | ..      | ...       | ...            |

---
### Опция 1 - Проблеми

- Ако искаме да намираме приятели на приятели или да намерим мрежа от приятели, трябва да направим много сложни **join** заявки, които могат значително да се забавят при много данни.
---
```sql
SELECT f2.*
FROM users u1
JOIN friendships f1 ON u1.id = f1.user_id
JOIN users u2 ON f1.friend_id = u2.id
JOIN friendships f2 ON u2.id = f2.user_id
WHERE u1.id = 123
```
---
### Опция 2 - Graph БД

- Всеки потребител е възел.
- Всяко приятелство е връзка между възлите.
- Можем да минаваме през възлите бързо.
---
```cypher
// Neo4j query to find friends of friends who aren't already friends
MATCH (me:User {id: '123'})-[:FRIENDS_WITH]->(friend)-[:FRIENDS_WITH]->(fof)
WHERE NOT (me)-[:FRIENDS_WITH]->(fof)
RETURN fof
```
---
### Graph БД - Предимства

- Лесно моделираме и обхождане на сложни връзки.
- Скоростта не се влошава при увеличаване на данните.
---
### Graph БД - Недостатъци

- Изискват повече памет.
- Не са подходящи, когато връзките са прости.
- По-лоша ACID поддръжка.
---
## Document

- Пази данните в гъвкави, полу-структурирани документи (Обикновено JSON, XML или др.).
- Позволяват ни да пазим сложни, гъвкави данни, без да ги разпределяме из базата данни.
- **Пример:** MongoDB.
---
## Document Use Case

- Разработваме публикации за социална мрежа.
- Всяка публикация има **заглавие, съдържание, автор, тагове, коментари (с отговори и метаданни).**
---
### Опция 1 - Релационна БД

- Трябва да създадем множество таблици:
    - `Posts` (post_id, title, content, author_id)
    - `Authors` (author_id, name, email)
    - `Tags` (tag_id, name)
    - `Post_Tags` (post_id, tag_id)
    - `Comments` (comment_id, post_id, text, user_id, parent_comment_id)
---
### Опция 2 - Document БД

- Всеки пост има отделен документ:
```json
{
  "_id": "post123",
  "title": "Why NoSQL is Awesome",
  "content": "Document databases are flexible...",
  "author": {
    "name": "Jane Doe",
    "email": "jane@example.com",
    "social_links": ["twitter.com/jane", "linkedin.com/jane"]
  },
  "tags": ["tech", "database", "nosql"],
  "comments": [
    {
      "text": "Great post!",
      "user": "user1",
      "replies": [
        { "text": "Thanks!", "user": "author_jane" }
      ]
    }
  ]
}
```
---
### Document БД - Предимства

- Лесно обработване на сложни данни.
- Данните могат да бъдат гъвкави.
- Скоростта не се влошава при увеличаване на данните.
---
### Document БД - Недостатъци

- Трудно нормализиране на данните.
- Когато трябва да поддържаме сложни релации между данните.
- По-лоша ACID поддръжка.
---
### Заключение

- За повечето приложения можем да използваме релационни данни, понеже дават по-добра сигурност и имат голям набор от приложения.
- Ако нашето приложение има по-специфични нужди можем да се замислим за нерелационна алтернатива.
